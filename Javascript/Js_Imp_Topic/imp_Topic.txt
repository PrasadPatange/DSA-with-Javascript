HTML 5 Interview Questions : 
https://www.interviewbit.com/html-interview-questions/

https://www.softwaretestinghelp.com/html5-interview-questions/

CSS Interview Questions :
https://www.interviewbit.com/css-interview-questions/


Javascript Interview Questions : 
https://www.interviewbit.com/javascript-interview-questions/


1. Temporal Dead Zone :
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz

2. Closure :
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures

3. JavaScript :
https://developer.mozilla.org/en-US/docs/Web/JavaScript

4. Hoisting :
 Hoisting : Variable can be used before it has been declared.
 
            JavaScript Hoisting : 

            https://www.geeksforgeeks.org/javascript-hoisting/

            What is hoisting with example in JavaScript?
            Hoisting in JavaScript is a behavior in which a function or a variable can be used before declaration. 
            For example, // using test before declaring console.log(test); // undefined var test; Run Code. The above program works and the output will be undefined .

            console.log(test); // undefined
            var test = "abc"; 

            interpreter see :

            var test;
            console.log(test); // undefined
            test = "abc";


5. Temporal Dead Zone :
- Temporal Dead Zone is the period of time during which the let and const declarations cannot be accessed.
- Temporal Dead Zone starts when the code execution enters the block which contains the let or const declaration and continues until the declaration has executed.  
-  Temporal deadzone is a time . since when this let variable are hoisted.

6. Lexical Scope :
 - Lexical scope is the definition area of an expression.
  In other words, an item's lexical scope is the place in which the item got created.
- JavaScript uses lexical scoping to resolve the variable names when a function is created inside another function. 
  It determines the function's parent scope by looking at where the function was created instead of where it was invoked.
- Lexical scope means that in a nested group of functions, the inner functions have access to the variables and other resources of their parent scope. This means that the child's functions are lexically bound to the execution context of their parents.
 Lexical scope is sometimes also referred to as static scope.

7. Closure : 
- A function with lexical scope is known as closure. 

- In JavaScript, a Closure is a function that references variables in the outer scope from its inner scope. 
- The closure preserves the outer scope inside its inner scope even after outer function is returned.

- Closure is a function , when you create another function from function and inner function access all data of outer function
  or parent function even after the outer function completed. or done with its execution. Its called Closure.

- A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment).
In other words, a closure gives you access to an outer function's scope from an inner function. 
In JavaScript, closures are created every time a function is created, at function creation time.

- A closure is the combination of a function and the lexical environment within which that function was declared. 

Important for closure :


Lexical Scope :
 - function ki outer value function ke andar access ho sakti hai,
   but function ki inner value function ke bahar access nahi hot sakti. 
 - We can access outer value/property inside inner function 
   but not access inner value/property of that function to outer /outside is called lexical scope.

   example :
   let data = 10;
        function test(){
            let a = 100;
            console.log("outer : ",data);
        }
        console.log("inner : ",a);  // throw error : Uncaught ReferenceError: a is not defined
        test();

8. Event propagation :
    Propagation refers to how events travel through the Document Object Model (DOM) tree. 
    The DOM tree is the structure which contains parent/child/sibling elements in relation to each other. 
    You can think of propagation as electricity running through a wire, until it reaches its destination.
    The event needs to pass through every node on the DOM until it reaches the end, or if it is forcibly stopped.
   

9. Event Bubbling :  ( Bottom To Top Approach ) : inner then outer
  - The Event bubbling in JavaScript is a type of event propagation. The event triggers the innermost target element and
   consecutively triggers the parent element of the target element in the same hierarchy until it triggers the outermost element.

  - Event bubbling is a method of event propagation in the HTML DOM API when an event is in an element inside another element, 
   and both elements have registered a handle to that event. It is a process that starts with the element that triggered the event and then bubbles up to the containing elements in the hierarchy. In event bubbling,
    the event is first captured and handled by the innermost element and then propagated to outer elements.

10. Event Capturing :  ( Top To Bottom Approach ) : outer then inner
  - The Event Capturing in JavaScript is a type of event propagation.same as Event Bubbling but Opposite.
    i.e. first parent then child.

11. Nullish Coalescing Operator : 
 - represent using '??'
 - It only checks undefined and null property. not check boolean,empty string,etc.

12. What is currying in JavaScript used for?
  - Currying is a checking method to make sure that you get everything you need before you proceed. 
  - It helps you to avoid passing the same variable again and again. It divides your function into multiple 
    smaller functions that can handle one responsibility.

13. Pure Functinons are Predictable , Readable , Reusable , Testable.
    What is Pure Functions ?
    => Pure Function should always give you same output whenever pass the same Input.
    => not depend on outer variable 
    => pure function not use console.log because console is external api not js function.

    What is Side Effect ?
    => any Operation not directly related to final output of a function is called side effect.


14. Difference Between Promise and Async await :
     https://www.geeksforgeeks.org/difference-between-promise-and-async-await-in-node-js/#:~:text=Async%2FAwait%20is%20used%20to,which%20is%20easier%20to%20understand.
             
             Promise                                                                 Async / Await
     1.	Promise is an object representing intermediate                       Async/Await is a syntactic sugar for promises, 
        state of operation which is guaranteed to                            a wrapper making the code execute more synchronously.
         complete its execution at some point in future.	 
        
      2.	Promise has 3 states – resolved, rejected and pending.             	It does not have any states.
                                                                              It returns a promise either resolved or rejected.
            
      3.	If the function “fxn1” is to executed after the promise,            If the function “fxn1” is to executed after await,    
          then promise.then(fxn1) continues execution of the current          then await X() suspends execution of the current function  
           function after adding the fxn1 call to the callback chain.	         and then fxn1 is executed.

      4.	Error handling is done using .then() and .catch() methods.          	Error handling is done using .try() and .catch() methods.

      5.	Promise chains can become difficult to understand sometimes.	       Using Async/Await makes it easier to read and understand
                                                                                the flow of the program as compared to promise chains.                                           




 15. IIFE (Immediately Invoked Function Expression): 
   -> An IIFE is a Javascript that runs as soon as it is defined.
   -> It is a design pattern which is also  known as a Self-Executing Anonymous Function.
   -> Ex :
            (function(){
              /* Logic */
            })();
            
  
  16. Callback Function :
    -> A callback function is a function passed into another function as an argument ,
      which is then invoked inside the outer function to complete some task....
      Ex :
    function fun1(){
      console.log('function 1');
    }
    function fun2(callback){
        console.log('function 2');
        callback();
    }
    fun2(fun1);

    17. Higher Order Function :
      -> A Higher Order Function is a function that takes as an argument, or returns a function.
      Ex : map
      map(function(){

      })


    18. Some Important Links : 
       
      Difference Between class and Interface
      https://javatpoint.com/typescript-class-vs-interface#:~:text=Classes%20are%20the%20fundamental%20entities%20used%20to%20create%20reusable%20components,a%20contract%20in%20our%20application.

      example interface :
      https://www.itsolutionstuff.com/post/how-to-use-interface-in-angularexample.html

      example enum : defines list of named constants
      https://www.telerik.com/blogs/angular-basics-working-enums#:~:text=Enums%20are%20one%20of%20the,values%20to%20non%2Dconst%20enums.

      Enums are one of the features exclusive to TypeScript. We can use them to define a list of named constants, which lets us create easier-to-understand code by documenting distinct cases.

      TypeScript includes numeric and string-based enums. And we can also assign computed values to non-const enums.

 ** Topic ** 
Shallow copy and Deep copy :
https://www.geeksforgeeks.org/what-is-shallow-copy-and-deep-copy-in-javascript/#:~:text=This%20is%20known%20as%20shallow,other%20one%20ceases%20to%20exist.
 
  19. Shallow copy : 

     => From the above example, 
     => it is seen that when the name of newEmployee is modified, 
        it is also reflected for the old employee object. This can cause data inconsistency.This is known as shallow copy.

     => The newly created object has the same memory address as the old one. 

     => Hence, any change made to either of them changes the attributes for both. To overcome this problem, deep copy is used.
        If one of them is removed from memory, the other one ceases to exist. In a way the two objects are interdependent.

 20. Deep Copy :

    => Unlike the shallow copy,
    =>  deep copy makes a copy of all the members of the old object, 
        allocates separate memory location for the new object and then assigns the copied members to the new object. 
        
    => In this way, both the objects are independent of each other and in case of any modification to either one the other is not affected. 
        Also, if one of the objects is deleted the other still remains in the memory. 
        Now to create a deep copy of an object in JavaScript we use JSON.parse() and JSON.stringify() methods. 
        Let us take an example to understand it better.
