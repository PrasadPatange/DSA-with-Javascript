
1. Temporal Dead Zone :
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz

2. Closure :
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures

3. JavaScript :
https://developer.mozilla.org/en-US/docs/Web/JavaScript

4. Hoisting :
 Hoisting : Variable can be used before it has been declared.

5. Temporal Dead Zone :
- Temporal Dead Zone is the period of time during which the let and const declarations cannot be accessed.
- Temporal Dead Zone starts when the code execution enters the block which contains the let or const declaration and continues until the declaration has executed.  
-  Temporal deadzone is a time . since when this let variable are hoisted.

6. Lexical Scope :
 - Lexical scope is the definition area of an expression.
  In other words, an item's lexical scope is the place in which the item got created.
- JavaScript uses lexical scoping to resolve the variable names when a function is created inside another function. 
  It determines the function's parent scope by looking at where the function was created instead of where it was invoked.
- Lexical scope means that in a nested group of functions, the inner functions have access to the variables and other resources of their parent scope. This means that the child's functions are lexically bound to the execution context of their parents.
 Lexical scope is sometimes also referred to as static scope.

7. Closure : 
- A function with lexical scope is known as closure. 

- A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment).
In other words, a closure gives you access to an outer function's scope from an inner function. 
In JavaScript, closures are created every time a function is created, at function creation time.

- A closure is the combination of a function and the lexical environment within which that function was declared. 

Important for closure :


Lexical Scope :
 - function ki outer value function ke andar access ho sakti hai,
   but function ki inner value function ke bahar access nahi hot sakti. 
 - We can access outer value/property inside inner function 
   but not access inner value/property of that function to outer /outside is called lexical scope.

   example :
   let data = 10;
        function test(){
            let a = 100;
            console.log("outer : ",data);
        }
        console.log("inner : ",a);  // throw error : Uncaught ReferenceError: a is not defined
        test();

8. Event propagation :
    Propagation refers to how events travel through the Document Object Model (DOM) tree. 
    The DOM tree is the structure which contains parent/child/sibling elements in relation to each other. 
    You can think of propagation as electricity running through a wire, until it reaches its destination.
    The event needs to pass through every node on the DOM until it reaches the end, or if it is forcibly stopped.
   

9. Event Bubbling :  ( Bottom To Top Approach ) : inner then outer
  - The Event bubbling in JavaScript is a type of event propagation. The event triggers the innermost target element and
   consecutively triggers the parent element of the target element in the same hierarchy until it triggers the outermost element.

  - Event bubbling is a method of event propagation in the HTML DOM API when an event is in an element inside another element, 
   and both elements have registered a handle to that event. It is a process that starts with the element that triggered the event and then bubbles up to the containing elements in the hierarchy. In event bubbling,
    the event is first captured and handled by the innermost element and then propagated to outer elements.

10. Event Capturing :  ( Top To Bottom Approach ) : outer then inner
  - The Event Capturing in JavaScript is a type of event propagation.same as Event Bubbling but Opposite.
    i.e. first parent then child.

11. Nullish Coalescing Operator : 
 - represent using '??'
 - It only checks undefined and null property. not check boolean,empty string,etc.

12. What is currying in JavaScript used for?
  - Currying is a checking method to make sure that you get everything you need before you proceed. 
  - It helps you to avoid passing the same variable again and again. It divides your function into multiple 
    smaller functions that can handle one responsibility.

13. Pure Functinons are Predictable , Readable , Reusable , Testable.
    What is Pure Functions ?
    => Pure Function should always give you same output whenever pass the same Input.
    => not depend on outer variable 
    => pure function not use console.log because console is external api not js function.

    What is Side Effect ?
    => any Operation not directly related to final output of a function is called side effect.


14. Difference Between Promise and Async await :
     https://www.geeksforgeeks.org/difference-between-promise-and-async-await-in-node-js/#:~:text=Async%2FAwait%20is%20used%20to,which%20is%20easier%20to%20understand.
             
             Promise                                                                 Async / Await
     1.	Promise is an object representing intermediate                       Async/Await is a syntactic sugar for promises, 
        state of operation which is guaranteed to                            a wrapper making the code execute more synchronously.
         complete its execution at some point in future.	 
        
      2.	Promise has 3 states – resolved, rejected and pending.             	It does not have any states.
                                                                              It returns a promise either resolved or rejected.
            
      3.	If the function “fxn1” is to executed after the promise,            If the function “fxn1” is to executed after await,    
          then promise.then(fxn1) continues execution of the current          then await X() suspends execution of the current function  
           function after adding the fxn1 call to the callback chain.	         and then fxn1 is executed.

      4.	Error handling is done using .then() and .catch() methods.          	Error handling is done using .try() and .catch() methods.

      5.	Promise chains can become difficult to understand sometimes.	       Using Async/Await makes it easier to read and understand
                                                                                the flow of the program as compared to promise chains.                                           